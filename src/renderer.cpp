#include "renderer.h"#include <format>#include <print>#include "hash.h"void Renderer::render(const std::string_view path) {  std::ranges::for_each(std::views::iota(0uz, _iter_per_slice), [&](size_t iter) {    _curr_iter = iter;    auto slices = _model->locator().slices();    std::ranges::for_each(slices, [&](size_t slice_index) {      std::println("Iter {}/{} Slice {}/{}", iter + 1, _iter_per_slice, slice_index + 1, slices.size());      render_slice(slices[slice_index]);    });    save(std::format("log/iter_{:03}_result.image3d", iter + 1));  });  if (!path.empty()) {    save(path);  }}void Renderer::render_slice(size_t index) {  _curr_slice = index;  const auto &locator = _model->locator();  auto lor_indices = locator.lorsForGivenSlice(index);  Texture2D target = _mich.slice_texture(index).tensor().to(torch::kCUDA); // [1, D, H, W]  Texture3D &source = _final_result;  source.set_requires_grad(true);  source.zero_grad();  Texture3D uniform_source;  if (!_use_adam) {    uniform_source = Texture3D(1.0f, _image_size.x, _image_size.y, _image_size.z, 1, torch::kCUDA);    uniform_source.set_requires_grad(true);    uniform_source.zero_grad();  }  Texture2D result(locator.bins().size(), locator.views().size(), 1, torch::kCUDA);  Texture2D uniform_result;  if (!_use_adam) {    uniform_result = Texture2D(locator.bins().size(), locator.views().size(), 1, torch::kCUDA);  }  render_lor(lor_indices, source, uniform_source, result, uniform_result);  torch::Tensor stat;  if (!_use_adam) {    Texture2D likelihood = target * result.clamp_min(1e-8f).log() - result;    torch::Tensor mean_likelihood = likelihood.tensor().mean();    stat = mean_likelihood.detach();    mean_likelihood.backward();    Texture3D dldi = source.grad();    uniform_result.tensor().mean().backward();    Texture3D drdi = uniform_source.grad();    Texture3D g = torch::where(drdi.tensor() > 1e-4f, (dldi / drdi).tensor(), torch::zeros_like(drdi.tensor()));    torch::NoGradGuard guard;    Texture3D update = torch::where(g.tensor() != 0.0f, source.tensor() * g.tensor(), 0.1f * g.tensor());    _mask = torch::where(update.tensor() != 0.0f, torch::ones_like(_mask.tensor()), _mask.tensor());    MARK_AS_UNUSED(source.add_(update).clamp_(0.0f, 1.0f));    if ((_curr_iter + 1) % 5 == 0) {      uniform_result.save(std::format("log/iter_{:03}/uniform_result/slice_{:03}.exr", _curr_iter + 1, index));    }  } else {    torch::nn::PoissonNLLLoss loss_fn(torch::nn::PoissonNLLLossOptions().log_input(true));    Texture2D log_result = result.clamp_min(1e-8f).log();    torch::Tensor loss = loss_fn(log_result.tensor(), target.tensor());    stat = loss.detach();    _optimizer.zero_grad();    loss.backward();    _optimizer.step();    torch::NoGradGuard guard;    Texture3D grad = source.grad();    _mask = torch::where(grad.tensor() != 0.0f, torch::ones_like(_mask.tensor()), _mask.tensor());    MARK_AS_UNUSED(source.clamp_(0.0f, 1.0f));  }  if ((_curr_iter + 1) % 5 == 0) {    result.save(std::format("log/iter_{:03}/result/slice_{:03}.exr", _curr_iter + 1, index));  }  torch::Tensor source_tensor = source.tensor().detach();  torch::Tensor statics =      torch::stack({stat, source_tensor.min(), source_tensor.max(), source_tensor.mean()}).to(torch::kCPU);  auto statics_data = statics.data_ptr<float>();  if (!_use_adam) {    std::println("likelihood: {}", statics_data[0]);  } else {    std::println("loss: {}", statics_data[0]);  }  std::println("source stats: min={}, max={}, mean={}", statics_data[1], statics_data[2], statics_data[3]);}template<std::ranges::view T>void Renderer::render_lor(T lor_indices, const Texture3D &source, const Texture3D &uniform_source, Texture2D &result,                          Texture2D &uniform_result) {  torch::Device device = torch::kCUDA;  size_t num_lors = std::ranges::distance(lor_indices);  static std::vector<int64_t> bin_indices;  static std::vector<int64_t> view_indices;  static std::vector<float> p0_data;  static std::vector<float> p1_data;  static std::vector<float> p0u_data;  static std::vector<float> p0v_data;  static std::vector<float> p1u_data;  static std::vector<float> p1v_data;  bin_indices.clear();  view_indices.clear();  p0_data.clear();  p1_data.clear();  p0u_data.clear();  p0v_data.clear();  p1u_data.clear();  p1v_data.clear();  bin_indices.reserve(num_lors);  view_indices.reserve(num_lors);  p0_data.reserve(num_lors * 3);  p1_data.reserve(num_lors * 3);  p0u_data.reserve(num_lors * 3);  p0v_data.reserve(num_lors * 3);  p1u_data.reserve(num_lors * 3);  p1v_data.reserve(num_lors * 3);  const auto &locator = _model->locator();  for (size_t lor_index = 0; lor_index < num_lors; ++lor_index) {    size_t bin_index = lor_indices[lor_index] % locator.bins().size();    size_t view_index = (lor_indices[lor_index] / locator.bins().size()) % locator.views().size();    auto event = _data_view.at(lor_indices[lor_index]);    bin_indices.push_back(static_cast<int64_t>(bin_index));    view_indices.push_back(static_cast<int64_t>(view_index));    p0_data.insert(p0_data.end(), {event.crystal1.geometry->position.x, event.crystal1.geometry->position.y,                                   event.crystal1.geometry->position.z});    p1_data.insert(p1_data.end(), {event.crystal2.geometry->position.x, event.crystal2.geometry->position.y,                                   event.crystal2.geometry->position.z});    p0u_data.insert(p0u_data.end(), {event.crystal1.geometry->directionU.x, event.crystal1.geometry->directionU.y,                                     event.crystal1.geometry->directionU.z});    p0v_data.insert(p0v_data.end(), {event.crystal1.geometry->directionV.x, event.crystal1.geometry->directionV.y,                                     event.crystal1.geometry->directionV.z});    p1u_data.insert(p1u_data.end(), {event.crystal2.geometry->directionU.x, event.crystal2.geometry->directionU.y,                                     event.crystal2.geometry->directionU.z});    p1v_data.insert(p1v_data.end(), {event.crystal2.geometry->directionV.x, event.crystal2.geometry->directionV.y,                                     event.crystal2.geometry->directionV.z});  }  torch::Tensor p0 = torch::from_blob(p0_data.data(), {static_cast<int64_t>(num_lors), 3}, torch::kFloat32).to(device);  torch::Tensor p1 = torch::from_blob(p1_data.data(), {static_cast<int64_t>(num_lors), 3}, torch::kFloat32).to(device);  torch::Tensor p0u =      torch::from_blob(p0u_data.data(), {static_cast<int64_t>(num_lors), 3}, torch::kFloat32).to(device);  torch::Tensor p0v =      torch::from_blob(p0v_data.data(), {static_cast<int64_t>(num_lors), 3}, torch::kFloat32).to(device);  torch::Tensor p1u =      torch::from_blob(p1u_data.data(), {static_cast<int64_t>(num_lors), 3}, torch::kFloat32).to(device);  torch::Tensor p1v =      torch::from_blob(p1v_data.data(), {static_cast<int64_t>(num_lors), 3}, torch::kFloat32).to(device);  torch::Tensor bin_idx =      torch::from_blob(bin_indices.data(), {static_cast<int64_t>(num_lors)}, torch::kInt64).to(device);  torch::Tensor view_idx =      torch::from_blob(view_indices.data(), {static_cast<int64_t>(num_lors)}, torch::kInt64).to(device);  // [N, N_crystal, 3]  torch::Tensor crystal0_samples;  torch::Tensor crystal1_samples;  if (_use_sobol) {    crystal0_samples = _crystal0_sobol.draw(num_lors * _samples_per_crystal)                           .reshape({static_cast<int64_t>(num_lors), static_cast<int64_t>(_samples_per_crystal), 3})                           .to(device);    crystal1_samples = _crystal1_sobol.draw(num_lors * _samples_per_crystal)                           .reshape({static_cast<int64_t>(num_lors), static_cast<int64_t>(_samples_per_crystal), 3})                           .to(device);  } else {    crystal0_samples =        torch::rand({static_cast<int64_t>(num_lors), static_cast<int64_t>(_samples_per_crystal), 3}, device);    crystal1_samples =        torch::rand({static_cast<int64_t>(num_lors), static_cast<int64_t>(_samples_per_crystal), 3}, device);  }  //[N, N_crystal, N_lor]  torch::Tensor tof_samples = torch::rand({static_cast<int64_t>(num_lors), static_cast<int64_t>(_samples_per_crystal),                                           static_cast<int64_t>(_samples_per_lor)},                                          device);  torch::Tensor values =      render_crystal(p0, p1, p0u, p0v, p1u, p1v, crystal0_samples, crystal1_samples, tof_samples, source); // [N]  result.assign(view_idx, bin_idx, torch::zeros_like(bin_idx), values);  if (!_use_adam) {    torch::Tensor uniform_values = render_crystal(p0, p1, p0u, p0v, p1u, p1v, crystal0_samples, crystal1_samples,                                                  tof_samples, uniform_source); // [N]    uniform_result.assign(view_idx, bin_idx, torch::zeros_like(bin_idx), uniform_values);  }}torch::Tensor Renderer::render_crystal(const torch::Tensor &p0, const torch::Tensor &p1, const torch::Tensor &p0u,                                       const torch::Tensor &p0v, const torch::Tensor &p1u, const torch::Tensor &p1v,                                       const torch::Tensor &crystal0_samples, const torch::Tensor &crystal1_samples,                                       const torch::Tensor &tof_samples, const Texture3D &source) const {  torch::Device device = torch::kCUDA;  int64_t num_lors = p0.size(0);  torch::Tensor crystal_sigma = torch::tensor(_crystal_sigma, device);  torch::Tensor tof_sigma_t = torch::tensor(_tof_sigma, device);  torch::Tensor tof_offset_t = torch::tensor(_tof_center_offset, device);  torch::Tensor voxel_size = torch::tensor({_voxel_size.x, _voxel_size.y, _voxel_size.z}, device);  torch::Tensor image_size = torch::tensor({_image_size.x, _image_size.y, _image_size.z}, device);  // [N, N_crystal, 3]  torch::Tensor crystal0_offsets = gaussian_sample(crystal0_samples, crystal_sigma);  torch::Tensor crystal1_offsets = gaussian_sample(crystal1_samples, crystal_sigma);  torch::Tensor crystal0_offsets_u = crystal0_offsets.select(-1, 0).unsqueeze(-1); // [N, N_crystal, 1]  torch::Tensor crystal0_offsets_v = crystal0_offsets.select(-1, 1).unsqueeze(-1);  torch::Tensor crystal1_offsets_u = crystal1_offsets.select(-1, 0).unsqueeze(-1); // [N, N_crystal, 1]  torch::Tensor crystal1_offsets_v = crystal1_offsets.select(-1, 1).unsqueeze(-1);  // [N, N_crystal, 3]  torch::Tensor p0d = p0.unsqueeze(1) + crystal0_offsets_u * (p0u.unsqueeze(1) * _crystal_size.x) / 2 +                      crystal0_offsets_v * (p0v.unsqueeze(1) * _crystal_size.y) / 2;  torch::Tensor p1d = p1.unsqueeze(1) + crystal1_offsets_u * (p1u.unsqueeze(1) * _crystal_size.x) / 2 +                      crystal1_offsets_v * (p1v.unsqueeze(1) * _crystal_size.y) / 2;  // [N, N_crystal, 1]  torch::Tensor length = torch::norm(p1d - p0d, 2, 2, true);  torch::Tensor x; // [N, N_crystal, N_lor]  if (_enable_importance_sampling && _tof_sigma > 0) {    x = gaussian_sample(tof_samples, tof_sigma_t, tof_offset_t);  } else {    x = (tof_samples - 0.5f) * length;  }  // [N, N_crystal, N_lor, 1]  torch::Tensor t = (0.5f + x / length).unsqueeze(-1);  t = torch::clamp(t, 0.0f, 1.0f);  // [N, N_crystal, N_lor, 3]  torch::Tensor p0d_exp = p0d.unsqueeze(2); // [N, N_crystal, 1, 3]  torch::Tensor p1d_exp = p1d.unsqueeze(2); // [N, N_crystal, 1, 3]  torch::Tensor pos = p0d_exp * (1.0f - t) + p1d_exp * t;  // [N, N_crystal, N_lor]  torch::Tensor dist = torch::norm(pos - p0d_exp, 2, 3) - length / 2.0f;  torch::Tensor tof_w = tof_weight(dist);  // [N, N_crystal, N_lor, 3]  torch::Tensor coord = (pos / voxel_size.unsqueeze(0).unsqueeze(0).unsqueeze(0) + 0.5f) /                            image_size.unsqueeze(0).unsqueeze(0).unsqueeze(0) +                        0.5f;  int64_t total_samples = num_lors * _samples_per_crystal * _samples_per_lor;  torch::Tensor coord_flat = coord.reshape({total_samples, 3});  // [total_samples, C]  torch::Tensor f_flat = source.eval_coords(coord_flat);  // [N, N_crystal, N_lor, C]  torch::Tensor f = f_flat.reshape(      {num_lors, static_cast<int64_t>(_samples_per_crystal), static_cast<int64_t>(_samples_per_lor), -1});  torch::Tensor pdf;  if (_enable_importance_sampling && _tof_sigma > 0) {    pdf = 1.0f / (std::sqrt(2.0f * std::numbers::pi_v<float>) * _tof_sigma) *          torch::exp(-0.5f * (x - _tof_center_offset) * (x - _tof_center_offset) /                     (_tof_sigma * _tof_sigma)); // [N, N_crystal, N_lor]  } else {    pdf = 1.0f / length.squeeze(-1); // [N, N_crystal]    pdf = pdf.unsqueeze(2); // [N, N_crystal, 1]  }  // [N, N_crystal, N_lor, C]  torch::Tensor tof_w_exp = tof_w.unsqueeze(-1);  torch::Tensor pdf_exp = pdf.unsqueeze(-1);  torch::Tensor weighted = f * tof_w_exp / (pdf_exp + 1e-8f);  // [N, N_crystal, C]  torch::Tensor lor_mean = weighted.mean(2);  // [N, C]  torch::Tensor crystal_mean = lor_mean.mean(1);  // [N]  torch::Tensor result = crystal_mean.squeeze(-1);  return result;}