#pragma once
#include<vector>
#include<optional>
#include<cstdint>
#include<array>
#include<variant>
#include<json.hpp>
#include<sstream>
namespace openpni::autogen{namespace json{using json=nlohmann::json;struct json_serializable{};

template<typename T>concept IsJsonSerializable=std::is_base_of_v<json_serializable,T>;template<IsJsonSerializable T>T struct_cast(const json&)noexcept;template<IsJsonSerializable T>json json_cast(const T&)noexcept;template <class... Ts> struct VariantVisitor : Ts... {using Ts::operator()...;};
};namespace binary{ struct binary_serializable{};template<typename T>concept IsBinarySerializable=std::is_base_of_v<binary_serializable,T>;template<IsBinarySerializable T>std::stringstream binary_cast(const T&)noexcept;template<IsBinarySerializable T>T struct_cast( std::stringstream&);};namespace json{struct PolygonalSystemDefine:public json_serializable{struct T_0:public json_serializable{struct T_1:public json_serializable{std::string src_addr{};int64_t src_port{};std::string dst_addr{};int64_t dst_port{};};std::string CalibrationFile{};T_1 IP{};};int64_t Edges{};int64_t DetectorPerEdge{};double DetectorLen{};double Radius{};double AngleOf1stPerp_degree{};int64_t DetectorRings{};double RingDistance{};std::string DetectorType{};std::vector<T_0> DetectorInfo{};};};namespace json{template<>PolygonalSystemDefine::T_0::T_1 struct_cast(const json&__json)noexcept;template<>PolygonalSystemDefine::T_0 struct_cast(const json&__json)noexcept;template<>PolygonalSystemDefine struct_cast(const json&__json)noexcept;

template<>json json_cast(const PolygonalSystemDefine::T_0::T_1&__struct)noexcept;template<>json json_cast(const PolygonalSystemDefine::T_0&__struct)noexcept;template<>json json_cast(const PolygonalSystemDefine&__struct)noexcept;};namespace json{template<>inline json json_cast(const PolygonalSystemDefine::T_0::T_1&__struct)noexcept{json result=json::object();result["src_addr"]=__struct.src_addr;result["src_port"]=__struct.src_port;result["dst_addr"]=__struct.dst_addr;result["dst_port"]=__struct.dst_port;return result;}template<>inline PolygonalSystemDefine::T_0 struct_cast(const json&__json)noexcept{PolygonalSystemDefine::T_0 result;if(__json.contains("CalibrationFile")&&__json["CalibrationFile"].is_string()){result.CalibrationFile=__json["CalibrationFile"].get<std::string>();}if(__json.contains("IP")&&__json["IP"].is_object()){result.IP=struct_cast<PolygonalSystemDefine::T_0::T_1>(__json["IP"]);}return result;}template<>inline json json_cast(const PolygonalSystemDefine&__struct)noexcept{json result=json::object();result["Edges"]=__struct.Edges;result["DetectorPerEdge"]=__struct.DetectorPerEdge;result["DetectorLen"]=__struct.DetectorLen;result["Radius"]=__struct.Radius;result["AngleOf1stPerp_degree"]=__struct.AngleOf1stPerp_degree;result["DetectorRings"]=__struct.DetectorRings;result["RingDistance"]=__struct.RingDistance;result["DetectorType"]=__struct.DetectorType;result["DetectorInfo"]=json::array();for(const auto&__$$:__struct.DetectorInfo)result["DetectorInfo"].push_back(json_cast(__$$));return result;}};namespace json{template<>inline PolygonalSystemDefine::T_0::T_1 struct_cast(const json&__json)noexcept{PolygonalSystemDefine::T_0::T_1 result;if(__json.contains("src_addr")&&__json["src_addr"].is_string()){result.src_addr=__json["src_addr"].get<std::string>();}if(__json.contains("src_port")&&__json["src_port"].is_number()){result.src_port=__json["src_port"].get<int64_t>();}if(__json.contains("dst_addr")&&__json["dst_addr"].is_string()){result.dst_addr=__json["dst_addr"].get<std::string>();}if(__json.contains("dst_port")&&__json["dst_port"].is_number()){result.dst_port=__json["dst_port"].get<int64_t>();}return result;}template<>inline json json_cast(const PolygonalSystemDefine::T_0&__struct)noexcept{json result=json::object();result["CalibrationFile"]=__struct.CalibrationFile;result["IP"]=json_cast(__struct.IP);return result;}template<>inline PolygonalSystemDefine struct_cast(const json&__json)noexcept{PolygonalSystemDefine result;if(__json.contains("Edges")&&__json["Edges"].is_number()){result.Edges=__json["Edges"].get<int64_t>();}if(__json.contains("DetectorPerEdge")&&__json["DetectorPerEdge"].is_number()){result.DetectorPerEdge=__json["DetectorPerEdge"].get<int64_t>();}if(__json.contains("DetectorLen")&&__json["DetectorLen"].is_number()){result.DetectorLen=__json["DetectorLen"].get<double>();}if(__json.contains("Radius")&&__json["Radius"].is_number()){result.Radius=__json["Radius"].get<double>();}if(__json.contains("AngleOf1stPerp_degree")&&__json["AngleOf1stPerp_degree"].is_number()){result.AngleOf1stPerp_degree=__json["AngleOf1stPerp_degree"].get<double>();}if(__json.contains("DetectorRings")&&__json["DetectorRings"].is_number()){result.DetectorRings=__json["DetectorRings"].get<int64_t>();}if(__json.contains("RingDistance")&&__json["RingDistance"].is_number()){result.RingDistance=__json["RingDistance"].get<double>();}if(__json.contains("DetectorType")&&__json["DetectorType"].is_string()){result.DetectorType=__json["DetectorType"].get<std::string>();}if(__json.contains("DetectorInfo")&&__json["DetectorInfo"].is_array()){result.DetectorInfo=decltype(result.DetectorInfo)();for(std::size_t __$$=0;__$$<__json["DetectorInfo"].size();__$$++)if(__json["DetectorInfo"][__$$].is_object())result.DetectorInfo.push_back(struct_cast<PolygonalSystemDefine::T_0>(__json["DetectorInfo"][__$$]));}return result;}};namespace binary{
#pragma pack(1)
struct BDM50100CaliFileV1:public binary_serializable{struct T_0:public binary_serializable{uint16_t IP{};uint16_t CH{};float K{};float KB{};float KX{};float A{};float B{};float KE{};};std::vector<std::array<float,64>> TDC{};std::vector<T_0> Energy{};};struct DeadTimeCalibration:public binary_serializable{std::vector<float> ActualRt{};std::vector<float> CFDT{};};struct MichRandomFactorsV1:public binary_serializable{std::vector<float> Factors{};};struct MichSelfNormFactorsV1:public binary_serializable{std::vector<float> SelfNormBlockA{};std::vector<float> SelfNormBlockT{};};struct NormalizationFactorsV1:public binary_serializable{std::vector<float> CryCount{};std::vector<float> BlockA{};std::vector<float> BlockT{};std::vector<float> Plane{};std::vector<float> Radial{};std::vector<float> Interference{};std::vector<float> CryFct{};};struct UChar2D:public binary_serializable{uint8_t X{};uint8_t Y{};};struct BDM2CaliFileV1:public binary_serializable{std::vector<float> EnergyCoefs{};std::vector<uint8_t> PositionTable{};std::vector<UChar2D> CenterPosition{};std::vector<float> EnergyProfile{};std::vector<uint32_t> CountMap{};std::vector<float> EnergyProfileCut{};};
#pragma pack()
};namespace binary{template<>BDM50100CaliFileV1::T_0 struct_cast( std::stringstream&__stream);template<>BDM50100CaliFileV1 struct_cast( std::stringstream&__stream);template<>DeadTimeCalibration struct_cast( std::stringstream&__stream);template<>MichRandomFactorsV1 struct_cast( std::stringstream&__stream);template<>MichSelfNormFactorsV1 struct_cast( std::stringstream&__stream);template<>NormalizationFactorsV1 struct_cast( std::stringstream&__stream);template<>UChar2D struct_cast( std::stringstream&__stream);template<>BDM2CaliFileV1 struct_cast( std::stringstream&__stream);template<>std::stringstream binary_cast(const BDM50100CaliFileV1::T_0&__struct)noexcept;template<>std::stringstream binary_cast(const BDM50100CaliFileV1&__struct)noexcept;template<>std::stringstream binary_cast(const DeadTimeCalibration&__struct)noexcept;template<>std::stringstream binary_cast(const MichRandomFactorsV1&__struct)noexcept;template<>std::stringstream binary_cast(const MichSelfNormFactorsV1&__struct)noexcept;template<>std::stringstream binary_cast(const NormalizationFactorsV1&__struct)noexcept;template<>std::stringstream binary_cast(const UChar2D&__struct)noexcept;template<>std::stringstream binary_cast(const BDM2CaliFileV1&__struct)noexcept;};namespace binary{template<>inline BDM50100CaliFileV1::T_0 struct_cast(std::stringstream&__stream){BDM50100CaliFileV1::T_0 result;const uint64_t __byte_begin=__stream.tellg();__stream.read((char*)&result,sizeof(result));if(!__stream.good())throw "Invalid Binary File At BDM50100CaliFileV1::T_0, INDEX 0" ;return result;}template<>inline BDM50100CaliFileV1 struct_cast(std::stringstream&__stream){BDM50100CaliFileV1 result;const uint64_t __byte_begin=__stream.tellg();
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_TDC;uint64_t size_of_Energy;}___TEMP___;
#pragma pack(pop)
__stream.read((char*)&___TEMP___,sizeof(___TEMP___));if(!__stream.good())throw "Invalid Binary File At BDM50100CaliFileV1, INDEX 0" ;const uint64_t __byte_end=__byte_begin+___TEMP___.__bytes;if(__byte_begin+___TEMP___.size_of_TDC*sizeof(std::array<float,64>)+___TEMP___.size_of_Energy*sizeof(BDM50100CaliFileV1::T_0)>__byte_end)throw "Invalid Binary File At BDM50100CaliFileV1, INDEX 1" ;result.TDC.resize(___TEMP___.size_of_TDC);__stream.read((char*)result.TDC.data(),sizeof(decltype(result.TDC)::value_type)*result.TDC.size());result.Energy.resize(___TEMP___.size_of_Energy);__stream.read((char*)result.Energy.data(),sizeof(decltype(result.Energy)::value_type)*result.Energy.size());return result;}template<>inline DeadTimeCalibration struct_cast(std::stringstream&__stream){DeadTimeCalibration result;const uint64_t __byte_begin=__stream.tellg();
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_ActualRt;uint64_t size_of_CFDT;}___TEMP___;
#pragma pack(pop)
__stream.read((char*)&___TEMP___,sizeof(___TEMP___));if(!__stream.good())throw "Invalid Binary File At DeadTimeCalibration, INDEX 0" ;const uint64_t __byte_end=__byte_begin+___TEMP___.__bytes;if(__byte_begin+___TEMP___.size_of_ActualRt*sizeof(float)+___TEMP___.size_of_CFDT*sizeof(float)>__byte_end)throw "Invalid Binary File At DeadTimeCalibration, INDEX 1" ;result.ActualRt.resize(___TEMP___.size_of_ActualRt);__stream.read((char*)result.ActualRt.data(),sizeof(decltype(result.ActualRt)::value_type)*result.ActualRt.size());result.CFDT.resize(___TEMP___.size_of_CFDT);__stream.read((char*)result.CFDT.data(),sizeof(decltype(result.CFDT)::value_type)*result.CFDT.size());return result;}template<>inline MichRandomFactorsV1 struct_cast(std::stringstream&__stream){MichRandomFactorsV1 result;const uint64_t __byte_begin=__stream.tellg();
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_Factors;}___TEMP___;
#pragma pack(pop)
__stream.read((char*)&___TEMP___,sizeof(___TEMP___));if(!__stream.good())throw "Invalid Binary File At MichRandomFactorsV1, INDEX 0" ;const uint64_t __byte_end=__byte_begin+___TEMP___.__bytes;if(__byte_begin+___TEMP___.size_of_Factors*sizeof(float)>__byte_end)throw "Invalid Binary File At MichRandomFactorsV1, INDEX 1" ;result.Factors.resize(___TEMP___.size_of_Factors);__stream.read((char*)result.Factors.data(),sizeof(decltype(result.Factors)::value_type)*result.Factors.size());return result;}template<>inline MichSelfNormFactorsV1 struct_cast(std::stringstream&__stream){MichSelfNormFactorsV1 result;const uint64_t __byte_begin=__stream.tellg();
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_SelfNormBlockA;uint64_t size_of_SelfNormBlockT;}___TEMP___;
#pragma pack(pop)
__stream.read((char*)&___TEMP___,sizeof(___TEMP___));if(!__stream.good())throw "Invalid Binary File At MichSelfNormFactorsV1, INDEX 0" ;const uint64_t __byte_end=__byte_begin+___TEMP___.__bytes;if(__byte_begin+___TEMP___.size_of_SelfNormBlockA*sizeof(float)+___TEMP___.size_of_SelfNormBlockT*sizeof(float)>__byte_end)throw "Invalid Binary File At MichSelfNormFactorsV1, INDEX 1" ;result.SelfNormBlockA.resize(___TEMP___.size_of_SelfNormBlockA);__stream.read((char*)result.SelfNormBlockA.data(),sizeof(decltype(result.SelfNormBlockA)::value_type)*result.SelfNormBlockA.size());result.SelfNormBlockT.resize(___TEMP___.size_of_SelfNormBlockT);__stream.read((char*)result.SelfNormBlockT.data(),sizeof(decltype(result.SelfNormBlockT)::value_type)*result.SelfNormBlockT.size());return result;}template<>inline NormalizationFactorsV1 struct_cast(std::stringstream&__stream){NormalizationFactorsV1 result;const uint64_t __byte_begin=__stream.tellg();
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_CryCount;uint64_t size_of_BlockA;uint64_t size_of_BlockT;uint64_t size_of_Plane;uint64_t size_of_Radial;uint64_t size_of_Interference;uint64_t size_of_CryFct;}___TEMP___;
#pragma pack(pop)
__stream.read((char*)&___TEMP___,sizeof(___TEMP___));if(!__stream.good())throw "Invalid Binary File At NormalizationFactorsV1, INDEX 0" ;const uint64_t __byte_end=__byte_begin+___TEMP___.__bytes;if(__byte_begin+___TEMP___.size_of_CryCount*sizeof(float)+___TEMP___.size_of_BlockA*sizeof(float)+___TEMP___.size_of_BlockT*sizeof(float)+___TEMP___.size_of_Plane*sizeof(float)+___TEMP___.size_of_Radial*sizeof(float)+___TEMP___.size_of_Interference*sizeof(float)+___TEMP___.size_of_CryFct*sizeof(float)>__byte_end)throw "Invalid Binary File At NormalizationFactorsV1, INDEX 1" ;result.CryCount.resize(___TEMP___.size_of_CryCount);__stream.read((char*)result.CryCount.data(),sizeof(decltype(result.CryCount)::value_type)*result.CryCount.size());result.BlockA.resize(___TEMP___.size_of_BlockA);__stream.read((char*)result.BlockA.data(),sizeof(decltype(result.BlockA)::value_type)*result.BlockA.size());result.BlockT.resize(___TEMP___.size_of_BlockT);__stream.read((char*)result.BlockT.data(),sizeof(decltype(result.BlockT)::value_type)*result.BlockT.size());result.Plane.resize(___TEMP___.size_of_Plane);__stream.read((char*)result.Plane.data(),sizeof(decltype(result.Plane)::value_type)*result.Plane.size());result.Radial.resize(___TEMP___.size_of_Radial);__stream.read((char*)result.Radial.data(),sizeof(decltype(result.Radial)::value_type)*result.Radial.size());result.Interference.resize(___TEMP___.size_of_Interference);__stream.read((char*)result.Interference.data(),sizeof(decltype(result.Interference)::value_type)*result.Interference.size());result.CryFct.resize(___TEMP___.size_of_CryFct);__stream.read((char*)result.CryFct.data(),sizeof(decltype(result.CryFct)::value_type)*result.CryFct.size());return result;}template<>inline UChar2D struct_cast(std::stringstream&__stream){UChar2D result;const uint64_t __byte_begin=__stream.tellg();__stream.read((char*)&result,sizeof(result));if(!__stream.good())throw "Invalid Binary File At UChar2D, INDEX 0" ;return result;}template<>inline BDM2CaliFileV1 struct_cast(std::stringstream&__stream){BDM2CaliFileV1 result;const uint64_t __byte_begin=__stream.tellg();
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_EnergyCoefs;uint64_t size_of_PositionTable;uint64_t size_of_CenterPosition;uint64_t size_of_EnergyProfile;uint64_t size_of_CountMap;uint64_t size_of_EnergyProfileCut;}___TEMP___;
#pragma pack(pop)
__stream.read((char*)&___TEMP___,sizeof(___TEMP___));if(!__stream.good())throw "Invalid Binary File At BDM2CaliFileV1, INDEX 0" ;const uint64_t __byte_end=__byte_begin+___TEMP___.__bytes;if(__byte_begin+___TEMP___.size_of_EnergyCoefs*sizeof(float)+___TEMP___.size_of_PositionTable*sizeof(uint8_t)+___TEMP___.size_of_EnergyProfile*sizeof(float)+___TEMP___.size_of_CountMap*sizeof(uint32_t)+___TEMP___.size_of_EnergyProfileCut*sizeof(float)>__byte_end)throw "Invalid Binary File At BDM2CaliFileV1, INDEX 1" ;result.EnergyCoefs.resize(___TEMP___.size_of_EnergyCoefs);__stream.read((char*)result.EnergyCoefs.data(),sizeof(decltype(result.EnergyCoefs)::value_type)*result.EnergyCoefs.size());result.PositionTable.resize(___TEMP___.size_of_PositionTable);__stream.read((char*)result.PositionTable.data(),sizeof(decltype(result.PositionTable)::value_type)*result.PositionTable.size());result.EnergyProfile.resize(___TEMP___.size_of_EnergyProfile);__stream.read((char*)result.EnergyProfile.data(),sizeof(decltype(result.EnergyProfile)::value_type)*result.EnergyProfile.size());result.CountMap.resize(___TEMP___.size_of_CountMap);__stream.read((char*)result.CountMap.data(),sizeof(decltype(result.CountMap)::value_type)*result.CountMap.size());result.EnergyProfileCut.resize(___TEMP___.size_of_EnergyProfileCut);__stream.read((char*)result.EnergyProfileCut.data(),sizeof(decltype(result.EnergyProfileCut)::value_type)*result.EnergyProfileCut.size());for(uint64_t ____=0;____<___TEMP___.size_of_CenterPosition;____++)result.CenterPosition.push_back(struct_cast<UChar2D>(__stream));return result;}};namespace binary{template<>inline std::stringstream binary_cast(const BDM50100CaliFileV1::T_0 & __struct) noexcept {std::stringstream result;result.write((char*)&__struct,sizeof(__struct));return result;}template<>inline std::stringstream binary_cast(const BDM50100CaliFileV1 & __struct) noexcept {std::stringstream result;
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_TDC;uint64_t size_of_Energy;__TEMP__(const BDM50100CaliFileV1&__struct){ size_of_TDC=__struct.TDC.size(); size_of_Energy=__struct.Energy.size();}}___TEMP___(__struct);
#pragma pack(pop)
result.write((char*)&___TEMP___,sizeof(___TEMP___));result.write((char*)__struct.TDC.data(),sizeof(decltype(__struct.TDC)::value_type)*__struct.TDC.size());result.write((char*)__struct.Energy.data(),sizeof(decltype(__struct.Energy)::value_type)*__struct.Energy.size());___TEMP___.__bytes=result.tellp();result.seekp(0,std::ios_base::beg);result.write((char*)&___TEMP___,sizeof(___TEMP___));result.seekp(___TEMP___.__bytes,std::ios_base::beg);return result;}template<>inline std::stringstream binary_cast(const DeadTimeCalibration & __struct) noexcept {std::stringstream result;
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_ActualRt;uint64_t size_of_CFDT;__TEMP__(const DeadTimeCalibration&__struct){ size_of_ActualRt=__struct.ActualRt.size(); size_of_CFDT=__struct.CFDT.size();}}___TEMP___(__struct);
#pragma pack(pop)
result.write((char*)&___TEMP___,sizeof(___TEMP___));result.write((char*)__struct.ActualRt.data(),sizeof(decltype(__struct.ActualRt)::value_type)*__struct.ActualRt.size());result.write((char*)__struct.CFDT.data(),sizeof(decltype(__struct.CFDT)::value_type)*__struct.CFDT.size());___TEMP___.__bytes=result.tellp();result.seekp(0,std::ios_base::beg);result.write((char*)&___TEMP___,sizeof(___TEMP___));result.seekp(___TEMP___.__bytes,std::ios_base::beg);return result;}template<>inline std::stringstream binary_cast(const MichRandomFactorsV1 & __struct) noexcept {std::stringstream result;
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_Factors;__TEMP__(const MichRandomFactorsV1&__struct){ size_of_Factors=__struct.Factors.size();}}___TEMP___(__struct);
#pragma pack(pop)
result.write((char*)&___TEMP___,sizeof(___TEMP___));result.write((char*)__struct.Factors.data(),sizeof(decltype(__struct.Factors)::value_type)*__struct.Factors.size());___TEMP___.__bytes=result.tellp();result.seekp(0,std::ios_base::beg);result.write((char*)&___TEMP___,sizeof(___TEMP___));result.seekp(___TEMP___.__bytes,std::ios_base::beg);return result;}template<>inline std::stringstream binary_cast(const MichSelfNormFactorsV1 & __struct) noexcept {std::stringstream result;
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_SelfNormBlockA;uint64_t size_of_SelfNormBlockT;__TEMP__(const MichSelfNormFactorsV1&__struct){ size_of_SelfNormBlockA=__struct.SelfNormBlockA.size(); size_of_SelfNormBlockT=__struct.SelfNormBlockT.size();}}___TEMP___(__struct);
#pragma pack(pop)
result.write((char*)&___TEMP___,sizeof(___TEMP___));result.write((char*)__struct.SelfNormBlockA.data(),sizeof(decltype(__struct.SelfNormBlockA)::value_type)*__struct.SelfNormBlockA.size());result.write((char*)__struct.SelfNormBlockT.data(),sizeof(decltype(__struct.SelfNormBlockT)::value_type)*__struct.SelfNormBlockT.size());___TEMP___.__bytes=result.tellp();result.seekp(0,std::ios_base::beg);result.write((char*)&___TEMP___,sizeof(___TEMP___));result.seekp(___TEMP___.__bytes,std::ios_base::beg);return result;}template<>inline std::stringstream binary_cast(const NormalizationFactorsV1 & __struct) noexcept {std::stringstream result;
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_CryCount;uint64_t size_of_BlockA;uint64_t size_of_BlockT;uint64_t size_of_Plane;uint64_t size_of_Radial;uint64_t size_of_Interference;uint64_t size_of_CryFct;__TEMP__(const NormalizationFactorsV1&__struct){ size_of_CryCount=__struct.CryCount.size(); size_of_BlockA=__struct.BlockA.size(); size_of_BlockT=__struct.BlockT.size(); size_of_Plane=__struct.Plane.size(); size_of_Radial=__struct.Radial.size(); size_of_Interference=__struct.Interference.size(); size_of_CryFct=__struct.CryFct.size();}}___TEMP___(__struct);
#pragma pack(pop)
result.write((char*)&___TEMP___,sizeof(___TEMP___));result.write((char*)__struct.CryCount.data(),sizeof(decltype(__struct.CryCount)::value_type)*__struct.CryCount.size());result.write((char*)__struct.BlockA.data(),sizeof(decltype(__struct.BlockA)::value_type)*__struct.BlockA.size());result.write((char*)__struct.BlockT.data(),sizeof(decltype(__struct.BlockT)::value_type)*__struct.BlockT.size());result.write((char*)__struct.Plane.data(),sizeof(decltype(__struct.Plane)::value_type)*__struct.Plane.size());result.write((char*)__struct.Radial.data(),sizeof(decltype(__struct.Radial)::value_type)*__struct.Radial.size());result.write((char*)__struct.Interference.data(),sizeof(decltype(__struct.Interference)::value_type)*__struct.Interference.size());result.write((char*)__struct.CryFct.data(),sizeof(decltype(__struct.CryFct)::value_type)*__struct.CryFct.size());___TEMP___.__bytes=result.tellp();result.seekp(0,std::ios_base::beg);result.write((char*)&___TEMP___,sizeof(___TEMP___));result.seekp(___TEMP___.__bytes,std::ios_base::beg);return result;}template<>inline std::stringstream binary_cast(const UChar2D & __struct) noexcept {std::stringstream result;result.write((char*)&__struct,sizeof(__struct));return result;}template<>inline std::stringstream binary_cast(const BDM2CaliFileV1 & __struct) noexcept {std::stringstream result;
#pragma pack(push,1)
struct __TEMP__{uint64_t __bytes;uint64_t size_of_EnergyCoefs;uint64_t size_of_PositionTable;uint64_t size_of_CenterPosition;uint64_t size_of_EnergyProfile;uint64_t size_of_CountMap;uint64_t size_of_EnergyProfileCut;__TEMP__(const BDM2CaliFileV1&__struct){ size_of_EnergyCoefs=__struct.EnergyCoefs.size(); size_of_PositionTable=__struct.PositionTable.size(); size_of_CenterPosition=__struct.CenterPosition.size(); size_of_EnergyProfile=__struct.EnergyProfile.size(); size_of_CountMap=__struct.CountMap.size(); size_of_EnergyProfileCut=__struct.EnergyProfileCut.size();}}___TEMP___(__struct);
#pragma pack(pop)
result.write((char*)&___TEMP___,sizeof(___TEMP___));result.write((char*)__struct.EnergyCoefs.data(),sizeof(decltype(__struct.EnergyCoefs)::value_type)*__struct.EnergyCoefs.size());result.write((char*)__struct.PositionTable.data(),sizeof(decltype(__struct.PositionTable)::value_type)*__struct.PositionTable.size());result.write((char*)__struct.EnergyProfile.data(),sizeof(decltype(__struct.EnergyProfile)::value_type)*__struct.EnergyProfile.size());result.write((char*)__struct.CountMap.data(),sizeof(decltype(__struct.CountMap)::value_type)*__struct.CountMap.size());result.write((char*)__struct.EnergyProfileCut.data(),sizeof(decltype(__struct.EnergyProfileCut)::value_type)*__struct.EnergyProfileCut.size());for(const auto&__item__:__struct.CenterPosition)result<<binary_cast(__item__).str();___TEMP___.__bytes=result.tellp();result.seekp(0,std::ios_base::beg);result.write((char*)&___TEMP___,sizeof(___TEMP___));result.seekp(___TEMP___.__bytes,std::ios_base::beg);return result;}};}
